#ifndef SRC_S21_DECIMAL_H_
#define SRC_S21_DECIMAL_H_

typedef struct s21_decimal {
    int bits[4];
} s21_decimal;

// Thank Steve for these beautiful macros https://stackoverflow.com/a/263738
#define S21_BIT_SET(target, bit_num) ((target) |= (1ULL << (bit_num)))
#define S21_BIT_CLEAR(target, bit_num) ((target) &= ~(1ULL << (bit_num)))
#define S21_BIT_FLIP(target, bit_num) ((target) ^= (1ULL << (bit_num)))

void s21_change_sign(s21_decimal *decimal);

// Двоичное представление
// Двоичное представление Decimal состоит из 1-разрядного знака, 96-разрядного
// целого числа и коэффициента масштабирования, используемого для деления целого
// числа и указания того, какая его часть является десятичной дробью.
// Коэффициент масштабирования неявно равен числу 10, возведенному в степень в
// диапазоне от 0 до 28.

// Decimal число может быть реализовано в виде четырехэлементного массива
// 32-разрядных целых чисел со знаком (int bits[4];).

// bits[0], bits[1], и bits[2] содержат младшие, средние и старшие 32 бита
// 96-разрядного целого числа соответственно.

// bits[3] содержит коэффициент масштабирования и знак, и состоит из следующих
// частей:

// Биты от 0 до 15, младшее слово, не используются и должны быть равны нулю.
// Биты с 16 по 23 должны содержать показатель степени от 0 до 28, который
// указывает степень 10 для разделения целого числа. Биты с 24 по 30 не
// используются и должны быть равны нулю. Бит 31 содержит знак; 0 означает
// положительный, а 1 означает отрицательный. Обратите внимание, что битовое
// представление различает отрицательные и положительные нули. Эти значения
// могут считаться эквивалентными во всех операциях.

#endif  // SRC_S21_MATH_H_